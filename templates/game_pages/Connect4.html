{% raw %}
<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>CodePen - Angular Connect 4 &amp; Simple AI</title>
  <link rel="stylesheet" href="./style.css">

</head>
<body>
<!-- partial:index.partial.html -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<div class="container" ng-app="connectFour" ng-controller="mainController as main">
  <div ng-show="main.modal" class="modal" ng-click="main.modal = false">
    <div class="modal-inner">
      <span class="modalx" ng-click="main.modal = false">X</span>
      <p>This project started with me wondering how difficult it would be to make connect 4 with HTML/CSS/JS. I built a quick prototype with jQuery and was pleased that it worked. I ended up switching to Angular mostly because of the huge stack of html that I had to insert to get all of the cells, and thought Angular's repeater would work nicely for that.</p>

      <p>Before talking about the AI, I'd like to mention that since building this I've read about mathematically perfect connect 4 AI's that look at every possible game path and <u>always</u> choose the best option and can't be beat (but can be tied). This AI is not that. I wanted to build the computer to play how a human plays the game. First the computer will say 'can I win right now?' and take action if it can. Failing that, it will say 'can the opponent win as soon as they go?' at which point it will prevent that. After that it will re-examine both of those scenarios, but 2 turns out rather than one. If all of that fails, it will just play randomly. It does this by looking for patterns in the horizontal rows, vertical columns, and diagonals. For example, it knows that if this exists in a horizontal row: [0,r,r,r] (r being red, 0 being empty) it needs to first check if there's anything under that 0 for it's piece to land on, and if so, play there to block the opponents win.</p>

      <p>If you're a developer, feel free to fork this off and make something cool, just attribute me please =]</p>
    </div>
  </div>
  <div class="wrap winner-{{main.winner}}">
    <!--<h2>Angular Connect 4</h2>-->
    <div class="buttons">
      <!--<h4>Game Type:</h4>-->
      <label><input type="radio" ng-model="main.playType" name="gameType" value="2" /> 2 player (Local)</label>
      <label><input type="radio" ng-model="main.playType" name="gameType" value="1" /> AI (In Dev)</label>
    </div>
    <div class="board active-{{main.active}}">
      <span class="row" ng-repeat="row in main.boardState track by $index">
        <div ng-repeat="cell in row track by $index" class="cell active-{{cell}}" ng-click="main.drop($parent.$index,$index)"></div>
        <p style="clear:both;"></p>
      </span>
      <div class="leftFoot"></div>
      <div class="rightFoot"></div>
    </div>
    <div style="clear:both"></div>
    <button class="reset" ng-click="main.init()">Reset</button>
    <!--<button class="about" ng-click="main.modal = true">About</button>
    <div ng-show="main.playType == 1" class="aicomments" scroll-glue>
      <h3>AI Comments</h3>
      <div class="comment" ng-repeat="comment in main.aiComments track by $index">{{comment}}</div>
    </div>-->
    <h2 ng-show="main.winner">Winner is {{main.winner}}</h2>
  </div>
</div>
<!-- partial -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.5.2/angular.min.js'></script>
<script src='https://cdn.rawgit.com/Luegg/angularjs-scroll-glue/master/src/scrollglue.js'></script><script  src="./script.js"></script>

</body>
</html>

<style>
.cell{
  width:50px;
  height:50px;
  position:relative;
  overflow:hidden;
  float:left;
  border:10px solid rgb(69, 170, 184)
}
.cell:before{
  content: '';
  position: absolute;
  bottom: 0%;
  width: 100%;
  height: 100%;
  border-radius: 100%;
  box-shadow: 0px 300px 0px 345px rgb(69, 170, 184);
}

p {
  clear:both;
  margin:0;
}

.board {
  width:490px;;
  margin:0 auto;
  position:relative;
  border:20px solid rgb(69, 170, 184);
  background:white;
}

.leftFoot, .rightFoot {
  background-color:rgb(69, 170, 184);
  width:30px;
  height:100px;
  float:left;
}

.leftFoot {
  margin-left:-20px;
}
.rightFoot {
  float:right;
  margin-right:-20px;
}

.leftFoot:after, .rightFoot:after {
  content:' ';
  width: 0; 
  height: 0; 
  border-left: 35px solid transparent;
  border-right: 35px solid transparent; 
  border-bottom: 80px solid rgb(69, 170, 184);
  position: absolute;
  bottom: -100px;
}

.leftFoot:after {
  left:-40px;
}
.rightFoot:after {
  right:-40px;
}

.active-r .cell:after {
  background-color: rgba(240, 107, 80,0.2);
  content: ' ';
  height: 120px;
  width: 120px;
  display: block;
  display:none;
}

.active-y .cell:after {
  background-color: rgba(225, 215, 114,0.2);
  content: ' ';
  height: 120px;
  width: 120px;
  display: block;
  display:none;
}

.cell:hover:after {
  display:block;
}

.cell.active-r:after {
  display:block;
  background-color: rgba(240, 107, 80,0.9);
}
.cell.active-y:after {
  display:block;
  background-color: rgba(225, 215, 114,0.9);
}

.reset {
  background-color:rgb(57, 66, 64);
  color:white;
  border:none;
  padding:10px;
  font-size:20px;
  text-align:center;
  /*width:10%;*/
  margin: 0 auto;
  display:block;
  margin-bottom:10px;
}

.about {
  background-color:rgb(127, 131, 130);
  color:white;
  border:none;
  padding:10px;
  font-size:20px;
  text-align:center;
  width:10%;
  margin:0 auto;
  display:block;
  margin-bottom:30px;
}


h2 {
  text-align:center;
  font-family:sans-serif;
  text-transform:uppercase;
}
.wrap  {
  display:block;
  height:100%;
  padding-top:40px;
}

.wrap.winner-red {
  background:rgb(240, 107, 80);
}

.wrap.winner-yellow {
  background:rgb(225, 215, 114);
}

.wrap.winner-yellow .cell:hover:after, .wrap.winner-red .cell:hover:after {
  display:none;
}

.wrap {
  color:rgb(57, 66, 64);
}

.buttons {
  text-align:center;
  margin-bottom:10px;
}

.modal {
    width: 100%;
    z-index: 999;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
}

.modal-inner {
    background: white;
    position: absolute;
    left: 20%;
    right: 20%;
    top: 20%;
    bottom: 20%;
    padding: 15px;
    overflow-x: hidden;
    overflow-y: scroll;
}

.modalx {
      text-align: right;
    font-family: sans-serif;
    float: right;
    padding: 8px 10px;
    background-color: rgba(0,0,0,0.2);
}

.modal p {
  margin-bottom:20px;
}

.aicomments {
  width: 50%;
    margin: 0 auto;
    text-align: center;
    border: 1px solid #B6B6B6;
    margin-bottom:20px;
    max-height:100px;
    overflow-y:scroll;
    overflow-x:hidden;
}

.aicomments h3 {
  background: rgb(57, 66, 64);
  margin: 0;
  padding: 10px;
  color: white;
  font-family:sans-serif;
}

.comment {
  text-align:left;
  background:white;
  padding:5px;
}
.comment:nth-child(even) {
  background:#ccc;
}

@media screen and (max-width:600px) {
  .board {
    width:252px;
  }
  .cell {
    width:32px;
    height:32px;
    border: 2px solid rgb(69, 170, 184);
  }
  .reset,.about {
    width:30%;
  }
}
</style>

<script>
angular.module('connectFour', ['luegg.directives'])

.controller('mainController', ['$scope', '$http', '$timeout', function($scope, $http, $timeout) {

    var vm = this;

    vm.init = function() {
        vm.boardState = [
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0]
        ];

        vm.active = 'r';

        vm.dropAllowed = true;

        vm.winner = false;

        vm.aiComments = ['Once you start playing, the AI will tell you why it\'s using specific moves here.'];
    };
    vm.init();

    vm.playType = 1;

    vm.modal = false;


    vm.winDetect = function() {
        var tempWinner = false;
        //horiz
        for (var i = 0; i < vm.boardState.length; i++) {
            var rowMatch = vm.boardState[i].join('').match(/r{4}|y{4}/);
            if (rowMatch) {
                rowMatch[0].indexOf("r") > -1 ? tempWinner = "red" : tempWinner = "yellow";
            }
        }
        //vertical
        var columns = vm.getColumns();
        for (var j = 0; j < columns.length; j++) {
            var colMatch = columns[j].join('').match(/r{4}|y{4}/);
            if (colMatch) {
                colMatch[0].indexOf("r") > -1 ? tempWinner = "red" : tempWinner = "yellow";
            }
        }
        //diag
        var diags = vm.getDiags();
        for (var l = 0; l < diags.length; l++) {
            var diagMatch = diags[l].join('').match(/r{4}|y{4}/);
            if (diagMatch) {
                diagMatch[0].indexOf("r") > -1 ? tempWinner = "red" : tempWinner = "yellow";
            }
        }
        return tempWinner;
    };

    vm.getColumns = function(){
        var columns = [];
        for (var j = 0; j < vm.boardState[0].length; j++) {
            var column = [];
            for (var k = 0; k < vm.boardState.length; k++) {
                column.push(vm.boardState[k][j]);
            }
            columns.push(column);
        }
        return columns;
    };

    vm.getDiags = function(arr) {
        if (typeof arr === 'undefined') arr = vm.boardState;
        var diags = [];
        for (var i = -5; i < 7; i++) {
            var group = [];
            for (var j = 0; j < 6; j++) {
                if ((i + j) >= 0 && (i + j) < 7) {
                    group.push(arr[j][i + j]);
                }
            }
            diags.push(group);
        }
        for (i = 0; i < 12; i++) {
            var group = [];
            for (var j = 5; j >= 0; j--) {
                if ((i - j) >= 0 && (i - j) < 7) {
                    group.push(arr[j][i - j]);
                }
            }
            diags.push(group);
        }
        return diags.filter(function(a) {
            return a.length > 3;
        });
    };

    vm.ai = function(){
        var decision = null;
        function threatDetect(lt, type) {
            //vertical threat assessment & response
            var columns = vm.getColumns();
            for (var i = 0; i < columns.length; i++) {
                var vertMatch;
                type == 'major' ? vertMatch = "0"+lt+lt+lt : vertMatch = "00"+lt+lt;
                var colMatch = columns[i].join('').match(vertMatch);
                if (colMatch) {
                    decision = i;
                    console.log('ai: responding to a '+type+' vertical '+responseType);
                    vm.aiComments.push('ai: responding to a '+type+' vertical '+responseType);
                }
            }

            if (!decision) {
                //horiz threat assessment & response
                var horizThreatPatterns;
                if (type == 'major') {
                    horizThreatPatterns = ['0'+lt+lt+lt, lt+'0'+lt+lt, lt+lt+'0'+lt, lt+lt+lt+'0'];
                }
                else {
                    horizThreatPatterns = ['00'+lt+lt, '0'+lt+lt+'0', '0'+lt+'0'+lt, lt+'0'+lt+'0', '0'+lt+lt+'0', lt+lt+'00'];
                }

                for (i = 0; i < vm.boardState.length; i++) {
                    var found = [];
                    var joined = vm.boardState[i].join('');
                    for (var j = 0; j < horizThreatPatterns.length; j++) {
                        var match = joined.match(horizThreatPatterns[j]);
                        if (match) found.push(match[0]);
                    }
                    if (found.length) {
                        var testCase = 0;
                        if (i == vm.boardState.length - 1) {
                            if (found[0] == '00yy' || found[0] == '00rr') testCase = 1;
                            decision = joined.indexOf(found[0])+found[0].indexOf('0')+testCase;
                            console.log('ai: responding to a '+type+' horizontal '+responseType);
                            vm.aiComments.push('ai: responding to a '+type+' horizontal '+responseType);
                        }
                        else {
                            matchPosition = joined.indexOf(found[0])+found[0].indexOf('0');
                            if (found[0] == '00yy' || found[0] == '00rr') matchPosition++;
                            if (vm.boardState[i+1][matchPosition]!==0) {
                                decision = matchPosition;
                                console.log('ai: responding to a '+type+' horizontal '+responseType);
                                vm.aiComments.push('ai: responding to a '+type+' horizontal '+responseType);
                            }
                        }
                    }
                }
            }

            if (!decision) {
                //diag threat assessment & response
                var diags = vm.getDiags();
                var diagThreatPatterns = ['0'+lt+lt+lt, lt+'0'+lt+lt, lt+lt+'0'+lt, lt+lt+lt+'0'];
                for (i = 0; i < diags.length; i++) {
                    var found = [];
                    var joined = diags[i].join('');
                    for (var j = 0; j < diagThreatPatterns.length; j++) {
                        var match = joined.match(diagThreatPatterns[j]);
                        if (match) found.push(match[0]);
                    }
                    if (found.length) {
                        for (var l = 0; l < found.length; l++) {
                            diagMap = vm.getDiags([[0,1,2,3,4,5,6],[7,8,9,10,11,12,13],[14,15,16,17,18,19,20],[21,22,23,24,25,26,27],[28,29,30,31,32,33,34],[35,36,37,38,39,40,41]]);
                            var vulnSlot = diagMap[i][found[l].indexOf('0')];
                            if ( typeof vm.boardState[Math.floor(vulnSlot/7)+1] === 'undefined' || vm.boardState[Math.floor(vulnSlot/7)+1][(vulnSlot%7)] !== 0) {
                                decision = vulnSlot%7;
                                console.log('ai: responding to a '+type+' diagonal '+responseType);
                                vm.aiComments.push('ai: responding to a '+type+' diagonal '+responseType);
                            }
                        }
                    }
                }
            }
        }

        function opportunityDetect(type) {
            //detecting our opportunities is just like detecting threats (mostly, 3 extra patterns)
            //we want to be defensive over offensive, so we only look for opportunities
            //if there are no immediate threats
            responseType = 'opportunity';
            threatDetect(vm.active,type);
        }

        //look for winning opportunities
        opportunityDetect('major');

        //if none, look for major threats
        if (decision === null) {
            var responseType = 'threat';
            threatDetect((vm.active == 'r' ? 'y' : 'r'), 'major');
        }

        //if none look for minor opportunities
        if (decision === null) {
            opportunityDetect('minor');
        }

        //if none look for minor threats
        if (decision === null) {
            var responseType = 'threat';
            threatDetect((vm.active == 'r' ? 'y' : 'r'), 'minor');
        }

        if (decision !== null && vm.boardState[0][decision] === 0) {
            vm.drop(0,decision);
        }
        else {
            console.log('ai: no threats or opportunities found, goin random');
            var random = Math.floor(Math.random() * 7);
            var failSafe = 0;
            var boardValue = vm.boardState[0][random];
            while (boardValue !== 0 && failSafe < 100) {
                random = Math.floor(Math.random() * 7);
                boardValue = vm.boardState[0][random];
                failSafe++;
            }
            vm.drop(0,random);
        }
    };

    vm.drop = function(index, index2) {
        if (vm.dropAllowed && vm.boardState[index][index2] === 0) {
            vm.dropAllowed = false;
            vm.boardState[0][index2] = vm.active;
            //recursive timeout loop
            (function dropLoop(i) {
                $timeout(function() {
                    if (typeof vm.boardState[i] !== 'undefined' && vm.boardState[i][index2] === 0 && i <= 5) {
                        vm.boardState[i - 1][index2] = 0;
                        vm.boardState[i][index2] = vm.active;
                        dropLoop(i + 1);
                    } else {
                        vm.active = (vm.active == 'r' ? 'y' : 'r');
                        vm.dropAllowed = true;
                        vm.winner = vm.winDetect();
                        if (vm.winner) {
                            vm.dropAllowed = false;
                        }
                        if (vm.playType == 1 && vm.active == 'y') {
                            //ai
                            vm.ai();                            
                        }
                    }
                }, 50);
            })(1);
        }
    };

}]);

/*
    To do list:
    hypothetical thinking ahead. Before the ai makes a move, see if that would put the other player in a winning position
*/
</script>
{% endraw %}
